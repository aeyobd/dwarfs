#!/usr/bin/python
__docstring__ = ("Find parameters of a DoublePowerLaw DF f(J) that best correspond "
"to the given spherical or flattened density profile model, optionally with anisotropic "
"velocity distribution.\n"
"This program generalizes the analogous C++ example_doublepowerlaw to a non-spherical case.\n"
"The procedure consists of several steps:\n"
"(1) Create the density and potential models with the provided parameters; "
"by default the potential corresponds to the density via the Poisson equation "
"but it may be provided separately in a non-self-consistent case. "
"The density and potential may be spherical or flattened axisymmetric.\n"
"(2) Construct a QuasiSpherical DF for this density-potential pair using the "
"Eddington inversion formula or its anisotropic Cuddeford-Osipkov-Merritt generalization. "
"In this step, the density and potential are sphericalized.\n"
"(3) Discretize the density on a radial grid covering almost all mass in the input profile "
"into the array of spherical and non-spherical constraints corresponding to l=0 and l=2 "
"multipole terms.\n"
"(4) Search for the parameters of a DoublePowerLaw DF that best approximate the discretized "
"density constraints and retain the prescribed velocity anisotropy profile (treated as "
"angular averaged ratio of sigma_phi to sigma_r).\n"
"(5) The resulting DF is not exactly corresponding to the input density profile, "
"so in the self-consistent case, a few iterations of recomputing the density and potential "
"are performed.\n"
"(6) If requested, generate an N-body snapshot from the model.\n"
"(7) Display diagnostic plots comparing the density profile generated by the DF "
"with the input model, and the velocity dispersion profiles along the major and minor "
"axes with the ones of the sphericalized model.\n\n"
"Command-line arguments:\n"
"  density=... - name of the density model or the name of an INI file with density parameters.\n"
"  scaleRadius, mass, ... - other parameters describing the density model (if given by name).\n"
"  potential=... - if provided, specifies an INI file with parameters of the potential "
"that may be different from the density profile (non-self-consistent case).\n"
"  beta0, r_a - parameters controlling the velocity anisotropy of the Cuddeford-Osipkov-Merritt "
"model (central value of the anisotropy and the radius beyond which it transitions to unity); "
"default values (0, infinity) generate isotropic models.\n"
"  slopeIn, slopeOut, steepness, coefJrIn, coefJrOut, coefJzIn, coefJzOut, Jcutoff, "
"cutoffStrength - if provided, fix the corresponding parameters of the DoublePowerLaw DF "
"to the given values; otherwise the best-fit values will be found during the optimization "
"procedure. In a spherical case, coefJz's are not independent but are fixed to (3-coefJr)/2. "
"These options may be helpful if the fit does not converge well; in particular, for density "
"profiles with power-law asymptotics, it may be worth keeping Jcutoff at infinity, "
"while for Sersic or Einasto-type profiles, one may choose to fit slopeIn, Jcutoff and "
"cutoffStrength while fixing J0 to a very large value and steepness to 1.\n"
"  nbody=..., out=..., format=(text) - if provided, generate an N-body realization of the model "
"with the given number of particles, writing it into the file specified by 'out' "
"in one of the available formats (text, nemo or gadget).\n\n"
"Example:\n"
"  python example_doublepowerlaw.py density=spheroid gamma=1 beta=4 q=0.6 beta0=-0.3\n"
"constructs a flattened Dehnen gamma=1 model with axis ratio z/x=0.6 and mild tangential anisotropy.")

import sys, os, numpy, scipy.optimize, agama, matplotlib.pyplot as plt
numpy.set_printoptions(linewidth=999, precision=5, suppress=True)

if len(sys.argv)<=1:
    exit(__docstring__)

############### parse parameters from command-line arguments or assign default values #############
arglist = []
for arg in sys.argv[1:]:
    nameval = arg.split('=')
    if len(nameval)!=2:
        raise ValueError('Command-line arguments should be in the form  name=value')
    arglist.append([nameval[0].upper(), nameval[1]])
args = dict(arglist)

def pop(dic, key, defaultValue=numpy.nan):
    if key.upper() in dic:
        val = dic[key.upper()]
        del dic[key.upper()]
        return val
    else:
        return defaultValue

def choose(x, y):
    return x if x==x else y

# some DF parameters may be kept fixed to the value specified as a command-line argument
defaultParams = {key: float(pop(args, key))
    for key in ('J0', 'slopeIn', 'slopeOut', 'steepness', 'coefJrIn', 'coefJrOut',
        'coefJzIn', 'coefJzOut', 'Jcutoff', 'cutoffStrength')}

beta0 = pop(args, 'beta0', 0)
r_a = pop(args, 'r_a', numpy.inf)
nbody = int(pop(args, 'nbody', 0))
outname = pop(args, 'out', '')
outformat = pop(args, 'format', 'text')
if (nbody==0) ^ (outname==''):
    exit('Need to provide both nbody=... (number of particles) and out=... (file name)\n')

# step (1): create the input density and potential models
potentialArg = pop(args, 'potential', '')
selfConsistent = potentialArg==''
if 'DENSITY' in args and os.path.isfile(args['DENSITY']):
    density = agama.Density(args['DENSITY'])
else:
    density = agama.Density(args)
totalMass = density.totalMass()
if selfConsistent:
    potential = agama.Potential(type='Multipole', density=density)
else:  # non-self-consistent model with an external potential specified in an INI file
    potential = agama.Potential(potentialArg)
spherical = 'SYMMETRY: SPHERICAL' in str(potential).upper()

# step (2): create the QuasiSpherical DF corresponding to the sphericalized density & potential

potsph = agama.Potential(type='Multipole', potential=potential, lmax=0)  # sphericalized potential
df0 = agama.DistributionFunction(type='QuasiSpherical', density=density, potential=potsph, beta0=beta0, r_a=r_a)
gmsph = agama.GalaxyModel(potsph, df0)
# Create an irregularly spaced radial grid such that the enclosed mass follows an S-shaped curve
# with smaller bins in mass at both ends and larger spacing around the half-mass region.
# Innermost radius and outermost radius exclude  ~totalMass*2.5/gridSize**2  from each end.
gridSize = 25
gridMass = density.totalMass() * numpy.sin(numpy.linspace(0, numpy.pi/2, gridSize+2)[1:-1])**2
gridRadius = 10**numpy.array([
    scipy.optimize.brentq(lambda logr: density.enclosedMass(10**logr) - mass, -100, 100)
    for mass in gridMass])
gridMajor = numpy.column_stack((gridRadius, 0*gridRadius, 0*gridRadius))
gridMinor = numpy.column_stack((gridRadius*0, gridRadius*0, gridRadius))
rhosph, velsqsph = gmsph.moments(gridMajor, dens=True, vel=False, vel2=True)  # used to specify the beta profile

# step (3): discretize the density profile on the radial grid and into two multipole terms (l=0 and l=2)

gridRadiusExt = numpy.hstack((0, gridRadius, gridRadius[-1]**2/gridRadius[-2]))
targetDensity = agama.Target(type='DensitySphHarm', lmax=2, mmax=0, gridr=gridRadiusExt)(density)
rhs_l0 = targetDensity[1:gridSize+1]     / totalMass
rhs_l2 = targetDensity[-(gridSize+1):-1] / totalMass
rhsBeta = 1 - velsqsph[:,1] / velsqsph[:,0]
# the third block in the r.h.s. corresponds to anisotropy constraints in the following way:
# the values of [(1-beta(r)) * sigma_r(r)^2 - sigma_phi(r)^2] / vnorm  are required to be zero,
# where beta(r) is the prescribed anisotropy profile stored in rhsBeta,
# and the division by vnorm (characteristic squared velocity) ensures that the values are of order unity.
rhs = numpy.hstack((rhs_l0, rhs_l2, numpy.zeros(gridSize)))

# To compute the density and velocity anisotropy profiles of the DF model, we use the following approach.
# First, a fiducial model is created with the initial QuasiSpherical DF (df0) embedded in the target potential
# (which may be non-spherical).
# Then this model is sampled into N>>1 equal-weight points (m0).
# Now the integral of any quantity A weighed by mass over the volume of a radial grid cell
# is given by \sum_i A(x_i,v_i) m0, where the iteration goes over all points "i" belonging to this cell,
# in other words, by Monte Carlo sampling over these points. 
# To compute this integral for a different choice of DF (df1), one performs the same sum, but with m0
# replaced by  m_i = m0 * df1(x_i,v_i) / df0(x_i,v_i);
# so m0/df0 is effectively the phase volume associated with i-th point.
gm0 = agama.GalaxyModel(potential, df0)
N = 1000000
xv0, m0 = gm0.sample(N)
act0  = gm0.af(xv0)
m0   /= totalMass
g     = m0 / df0(act0)  # phase volume associated with each point
r0    =  numpy.sum(xv0[:,0:3]**2, axis=1)**0.5
vr0sq = (numpy.sum(xv0[:,0:3]*xv0[:,3:6], axis=1) / r0)**2                    # v_r^2   for each point
vt0sq = (xv0[:,0]*xv0[:,4]-xv0[:,1]*xv0[:,3])**2 / (xv0[:,0]**2+xv0[:,1]**2)  # v_phi^2 for each point
vnorm = numpy.mean(vr0sq+vt0sq)  # characteristic squared velocity (to normalize the sigma values)
Jnorm = vnorm**0.5 * gridRadius[gridSize//2]  # characteristic scale action (to initialize the fit)
# values of the Legendre polynomial P_2(cos(theta)) at particle locations
P2 = (3*(xv0[:,2]/r0)**2 - 1) / 2 * 5**0.5

binind = numpy.searchsorted(gridRadiusExt, r0) - 1
assert numpy.all((binind>=0) & (binind<=gridSize+1))
matrixden0, matrixden2, matrixvrsq, matrixvtsq = numpy.zeros((4, gridSize, N))
for i in range(gridSize+1):
    use = binind==i
    mul = (r0[use] - gridRadiusExt[i]) / (gridRadiusExt[i+1] - gridRadiusExt[i])
    if i<gridSize:
        matrixden0[i,  use] +=    mul
        matrixden2[i,  use] +=    mul  * P2[use]
        matrixvrsq[i,  use] +=    mul  * vr0sq[use] / vnorm
        matrixvtsq[i,  use] +=    mul  * vt0sq[use] / vnorm
    if i>0:
        matrixden0[i-1,use] += (1-mul)
        matrixden2[i-1,use] += (1-mul) * P2[use]
        matrixvrsq[i-1,use] += (1-mul) * vr0sq[use] / vnorm
        matrixvtsq[i-1,use] += (1-mul) * vt0sq[use] / vnorm

#print('radius rho_l=0(req) (init) rho_l=2(req) (init) beta(req) (init)')
#print(numpy.column_stack([gridRadius,
#    rhs_l0, matrixden0.dot(m0),
#    rhs_l2, matrixden2.dot(m0),
#    rhsBeta, 1 - matrixvtsq.dot(m0)/ matrixvrsq.dot(m0)]))

# step (4): search for best-fit DoublePowerLaw DF parameters

def dfparams(params):
    par = dict(
        type      = "DoublePowerLaw",
        mass      = totalMass,
        J0        = choose(defaultParams['J0'],      10**params[0]),
        slopeIn   = choose(defaultParams['slopeIn'],     params[1]),
        slopeOut  = choose(defaultParams['slopeOut'],    params[2]),
        steepness = choose(defaultParams['steepness'],   params[3]),
        coefJrIn  = choose(defaultParams['coefJrIn'],    params[4]),
        coefJrOut = choose(defaultParams['coefJrOut'],   params[5]),
        Jcutoff   = choose(defaultParams['Jcutoff'], 10**params[8]),
        cutoffStrength = choose(defaultParams['cutoffStrength'], params[9]),
    )
    if spherical:
        par['coefJzIn']  = (3-par['coefJrIn' ])/2
        par['coefJzOut'] = (3-par['coefJrOut'])/2
    else:
        par['coefJzIn']  = choose(defaultParams['coefJzIn' ], params[6])
        par['coefJzOut'] = choose(defaultParams['coefJzOut'], params[7])
    return par

bounds = (
    numpy.array([-100, 0.0, 0.0, 0.2, 0.0, 0.0, 0.0, 0.0, -100, 0.2]),
    numpy.array([+100, 3.0, 20., 5.0, 3.0, 3.0, 3.0, 3.0, +100, 20.]))

linewidth = [0]  # used to erase the previously written string from the terminal
def optfnc(param, returnDF=False):
    try:
        if any(param < bounds[0]) or any (param > bounds[1]) or param[2]<param[1]:
            raise RuntimeError('invalid params')
        par = dfparams(param)
        df = agama.DistributionFunction(**par)
        m = df(act0) * g
        valden0 = matrixden0.dot(m)
        valden2 = matrixden2.dot(m)
        valvrsq = matrixvrsq.dot(m)
        valvtsq = matrixvtsq.dot(m)
        values = numpy.hstack((valden0, valden2, valvrsq * (1-rhsBeta) - valvtsq))
        deviation = (values - rhs)
        if returnDF:
            return df, valden0, valden2, valvrsq, valvtsq, deviation
        else:
            line = '%s => %.5g' % (param, sum(deviation**2))
            sys.stdout.write(' '*linewidth[0] + '\r' + line + '\r')
            sys.stdout.flush()
            linewidth[0] = len(line)
            return deviation
    except Exception as e:
        if returnDF:
            print(param)
            raise e
        else:
            return numpy.ones(len(rhs)) * numpy.inf

x = (numpy.log10(Jnorm), 2.0, 6.0, 1.0, 1.0, 1.0, 1.0, 1.0, numpy.log10(Jnorm), 2.0)
print('Starting optimization')
if True:
    x = scipy.optimize.leastsq(optfnc, x)[0]  # Levenberg-Marquardt method (does not support bounds)
else: # in case of poor convergence, one may try to use the alternative method below
    x = scipy.optimize.least_squares(optfnc, x, bounds=bounds).x
df, valden0, valden2, valvrsq, valvtsq, deviation = optfnc(x, returnDF=True)
print(' '*linewidth[0] + '\rFinished optimization')
print('radius rho_l=0(req) (actual) rho_l=2(req) (actual) beta(req) (actual)')
print(numpy.column_stack([gridRadius, rhs[0:gridSize], valden0,
    rhs[gridSize:2*gridSize], valden2, rhsBeta, 1 - valvtsq/valvrsq]))
print('penalty for l=0: %g, l=2: %g, beta: %g' %
    (sum(deviation[0:gridSize]**2), sum(deviation[gridSize:2*gridSize]**2), sum(deviation[2*gridSize:]**2)))
print('Final DF parameters:')
print('\n'.join(['%-15s = %s' % tuple(item) for item in dfparams(x).items()]))

# step (5): compute the density generated by the best-fit DoublePowerLaw DF
# either in its own potential (in the self-consistent case) or in the externally specified potential;
# this step is very similar to the one implemented in example_self_consistent_model_flattened.py

gridParams = dict(rminSph=gridRadius[1]*0.5, rmaxSph=gridRadius[-1], sizeRadialSph=gridSize,
    lmaxAngularSph=(0 if spherical else 8))
scm = agama.SelfConsistentModel(verbose=False, **gridParams)
scm.potential = potential
scm.components = [agama.Component(df=df, density=density, disklike=False, **gridParams)]
if selfConsistent:
    print('Constructing the self-consistent model corresponding to this DF')
    for it in range(4):
        print('Iteration %i, Phi(0)=%g' % (it, scm.potential.potential(0,0,0)))
        scm.iterate()
    potential = scm.potential
else:
    scm.iterate()  # only once, to compute the density generated by the DF in the _initial_ potential

# step (6), optional: create an N-body model

gm = agama.GalaxyModel(potential, df)
if nbody:
    print('Creating an N-body realization of the model witn %i particles and writing it to %s' % (nbody, outname))
    agama.writeSnapshot(outname, gm.sample(nbody), outformat)
else:
    print('If you need to create an N-body realization of this model, provide an nbody=... command-line argument')

# step (7): plots

print('Preparing diagnostic plots')
ax = plt.subplots(1, 4, figsize=(16,4), dpi=75)[1]
ax[0].plot(gridRadius, gridRadius**3 * density.density(gridMajor), color='m', label=r'$r^3 \rho_{\rm orig,major}$', dashes=[3,2])
ax[0].plot(gridRadius, gridRadius**3 * density.density(gridMinor), color='y', label=r'$r^3 \rho_{\rm orig,minor}$', dashes=[3,2])
ax[0].plot(gridRadius, gridRadius**3 * rhosph, color='gray', label=r'$r^3 \rho_{\rm sph}$', dashes=[1,1])
ax[1].plot(gridRadius, velsqsph[:,0]**0.5, color='b', label=r'$\sigma_{r,    \rm sph}$', dashes=[1,1])
ax[1].plot(gridRadius, velsqsph[:,2]**0.5, color='g', label=r'$\sigma_{\phi, \rm sph}$', dashes=[1,1])
ax[2].plot(gridRadius, velsqsph[:,2]**0.5, color='g', label=r'$\sigma_{\phi, \rm sph}$', dashes=[1,1])
ax[2].plot(gridRadius, velsqsph[:,0]**0.5, color='r', label=r'$\sigma_{z,    \rm sph}$', dashes=[1,1])

rhoMajor, velsqMajor = gm.moments(gridMajor, dens=True, vel=False, vel2=True)
rhoMinor, velsqMinor = gm.moments(gridMinor, dens=True, vel=False, vel2=True)
ax[0].plot(gridRadius, gridRadius**3 * rhoMajor, color='m', label=r'$r^3 \rho_{\rm final,major}$')
ax[0].plot(gridRadius, gridRadius**3 * rhoMinor, color='y', label=r'$r^3 \rho_{\rm final,minor}$')
ax[1].plot(gridRadius, velsqMajor[:,0]**0.5, color='b', label=r'$\sigma_{r,    \rm final}$')
ax[1].plot(gridRadius, velsqMajor[:,1]**0.5, color='g', label=r'$\sigma_{\phi, \rm final}$')
ax[1].plot(gridRadius, velsqMajor[:,2]**0.5, color='r', label=r'$\sigma_{z,    \rm final}$')
ax[2].plot(gridRadius, velsqMinor[:,1]**0.5, color='g', label=r'$\sigma_{\phi, \rm final}$') # equal in x,y directions
ax[2].plot(gridRadius, velsqMinor[:,2]**0.5, color='r', label=r'$\sigma_{z,    \rm final}$')
ax[1].set_ylim(0, numpy.max((velsqMajor, velsqMinor))**0.5*1.05)
ax[2].set_ylim(ax[1].get_ylim())

ax[3].plot(gridRadius, rhsBeta, color='c', dashes=[1,1], label=r'$\beta_{\rm orig}$')
ax[3].plot(gridRadius, 1 - valvtsq/valvrsq, color='c', label=r'$\beta_{\rm final}$')
principalAxes = density.principalAxes(gridRadius)[0]
ax[3].plot(gridRadius, principalAxes[:,2]/principalAxes[:,0], color='k', label=r'$(z/x)_{\rm orig}$', dashes=[3,2])
principalAxes = scm.components[0].density.principalAxes(gridRadius)[0]
ax[3].plot(gridRadius, principalAxes[:,2]/principalAxes[:,0], color='k', label=r'$(z/x)_{\rm final}$')
ax[3].set_ylim(-0.5, 1)

for a in ax:
    a.set_xscale('log')
    a.set_xlim(gridRadius[0], gridRadius[-1])
    a.legend(frameon=False)
    a.set_xlabel('radius')
ax[0].set_ylabel(r'$r^3 \rho$')
ax[1].set_ylabel(r'$\sigma$, major axis')
ax[2].set_ylabel(r'$\sigma$, minor axis')
ax[3].set_ylabel('velocity anisotropy and axis ratio')
ax[0].set_yscale('log')
ax[0].set_ylim(
    numpy.min((gridRadius**3 * density.density(gridMajor), gridRadius**3 * density.density(gridMinor)))*0.5,
    numpy.max((gridRadius**3 * density.density(gridMajor), gridRadius**3 * density.density(gridMinor)))*2.0)
plt.tight_layout()
plt.savefig(f"{outname}_recovery.pdf")
plt.show()
